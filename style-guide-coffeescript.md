# CoffeeScript Style Guide (локальный)

Автор: [Руслан Хуснетдинов](https://github.com/ruslankhh).

## Содержание

- [Предисловие](#Предисловие)
    - [Цель](#Цель)
    - [Профит](#Профит)
- [Правила](#Правила)
    - [1. Синтаксис](#1-Синтаксис)
        - [1.1. Стиль регистра: CamelCase](#11-Стиль-регистра-camelcase)
        - [1.2. ES6-стиль в CoffeeScript](#12-es6-стиль-в-coffeescript)
        - [1.3. Пробелы, отступы и переносы](#13-Пробелы-отступы-и-переносы)
        - [1.4. Название функции должно отражать ее назначение](#14-Название-функции-должно-отражать-ее-назначение)
        - [1.5. Комментарии — зло](#15-Комментарии--зло)
        - [1.6. Чистим мусор](#16-Чистим-мусор)
        - [1.7. Назначение функции должно соответствовать её названию](#17-Назначение-функции-должно-соответствовать-её-названию)
        - [1.8. ФП. Отказываемся от циклов](#18-ФП-Отказываемся-от-циклов)
        - [1.9. ООП. Общаемся с сущносями на их языке](#19-ООП-Общаемся-с-сущносями-на-их-языке)
    - [2. Работа с графом](#2-Работа-с-графом)
        - [2.1. Переменные](#21-Переменные)
        - [2.2. Шаг `init`. Инициализация](#22-Шаг-init-Инициализация)
        - [2.3. Шаг `render`. Рендеринг](#23-Шаг-render-Рендеринг)
        - [2.4. Шаг `start`. Начало](#24-Шаг-start-Начало)
        - [2.5. Шаг `continue`. Продолжение](#25-Шаг-continue-Продолжение)
        - [2.6. Шаг `deinit`. Окончание](#26-Шаг-deinit-Окончание)
- [Changelog](#changelog)

## Предисловие

Это руководство находится в разработке, все его постулаты не являются абсолютно истинными. Критика приветствуется. В процессе будет дополняться.

### Цель

Добиться кристализации **Единого стиля**. Что бы любой код в любом файле не был отличим по стилю от любого другого кода в любом другом файле. Как если бы он был написан одним человеком.

### Профит

Это болезненно, но профит от этого есть:
- применение лучших практик, которые будут понятны всем;
- более понятный код;
- уменьшение количества ошибок;
- уменьшение времени на разработку;
- уменьшение времени на понимание чужого кода;
- уменьшение времени на правки/поддержку;
- более лёгкий переход с CoffeeScript на ES6.

## Правила

### 1. Синтаксис

#### 1.1. Стиль регистра: CamelCase

Cейчас у нас много где встречается регистр [Snake_case](https://ru.wikipedia.org/wiki/Snake_case), это пришло к нам от Ruby-стов вместе с CoffeeScript-ом.

В мире JS везде стандартом является [CamelCase](https://ru.wikipedia.org/wiki/CamelCase) регистр. Это можно увидеть, например, в спецификациях [ECMAScript](https://www.ecma-international.org/ecma-262/)-а и [DOM](https://www.w3.org/TR/dom/)-а.

Стандартные методы (`@tutor.play_button(), $$.scene__draw()`) и методы компонентов остаются как есть.

Пример:

```coffee
# Не очень хорошо
$$.Script.prototype.init_dragger = () -> {...}

# Хорошо
$$.Script.prototype.initDragger = () -> {...}
```

#### 1.2. ES6-стиль в CoffeeScript

Так как у нас много кто пишет код "со скобочками", и много кто "без скобочек", это путает. Особенно если кто то в одном скрипте пишет и так и так.

Нужно выбрать что-то одно. И это — ES6-стиль ("со скобочками"). Так нам будет легче перейти на ES6 в будущем.

Запятые и точку с запятой (`,`, `;`) в конце строки и там, где они не нужны, можно не ставить.

Пример:

```coffee
# Не очень хорошо
@axis = new $$.Axis
  extrema: axis_extrema
  marksFilter: (point) => $$.fraction.parseToNumber(point.value) == @gen.value
  divisions:
    0:
      count: 2
      hidden: true

# Хорошо
@com.axis = new $$.Axis({
  extrema: axisExtrema
  marksFilter: (point) => $$.fraction.parseToNumber(point.value) == @gen.value
  divisions: {
    0: {
      count: 2
      hidden: true
    }
  }
})

```

#### 1.3. Пробелы, отступы и переносы

Пробелы не ствятся:

- между названием функции и скобкой;
- между двумя скобками (одного или разных видов);
- между ключом и двоеточием;

Пробелы ставятся:

- между логическими, математическими операторами и их операндами;
- после запятой;
- перед и после равенства (оператор присвоения);
- после двоеточия;
- перед и после стрелки в стрелочной функции;
- после открывающей и перед закрывающей скобкой, если объект записан в одну строчку;

Отсутпы: **2 пробела**.

Если есть цепочка вызовов, где каждый метод вызывается с новой строки, то эти методы должны быть на одном уровне, на следующем от объекта.

Переносы не ставятся:

- перед скобкой (если только перед ней не идет другая скобка того же вида);

Переносы ставятся:

- после скобок (скобка остается), если далее идет большой кусок кода;
- после стрелки в стрелочной функции (как блок инструкций);

```coffee
# Плохо
@dom.inputs = [0..1].map ( (value,i) =>
  $$.input ( {
    class:"input_ss_24"
    input:"s"
    state:"active"
    type:"s"
    choice_interface:{form:'horizontal',type:'comparison'}
    parent:@dom.inputContainer
  } )
  .data( {
    button:@com.button.view
    _symbols:@var.symbols[ i ]
  } )
)

# Хорошо
@dom.inputs = [0..1].map((value, i) =>
  $$.input({
    class: "input_ss_24"
    input: "s"
    state: "active"
    type: "s"
    choice_interface: { form: 'horizontal', type: 'comparison' }
    parent: @dom.inputContainer
  })
    .data({
      button: @com.button.view
      _symbols: @var.symbols[i]
    })
)
```

#### 1.4. Название функции должно отражать ее назначение

Название функций должно быть глаголом. Если помимо глагола нужны ещё какие то пояснения, то глагол должен стоять вначале. Функциями так же являются и шаги в графе, и методы скрипта.

Функция, которая возвращает булевое значение (`true` или `false`), назвается — [Предикат](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%B8%D0%BA%D0%B0%D1%82). Её название начинается с глагола `is...` (например: `isArray()`).

Пример:

```coffee
# Не очень хорошо
$$.Script.prototype.dragger = () -> {...}
$$.Script.prototype.right = () -> {...}

# Хорошо
$$.Script.prototype.renderDragger = () -> {...}
$$.Script.prototype.isRight = () -> {...}
```

#### 1.5. Комментарии — зло

Если вашему коду нужны комментарии, то значит нужно переписать этот код. В редких случаях без комментариев все таки не обойтись, особенно, если это документация.

В графе тоже лучше обойтись одними названиями методов без комментариев (и без скобочек).

**UPD: пожеланию, можно довалять комментарии в граф, если это вам нужно.**

Пример 1:

TODO: Вставить пример для комментариев в СoffeeScript-е.

Пример 2:

```
# Не очень хорошо
script_8348-->
(init: инициализация)-->
(render: отрисуем элементы первого экрана)-->
(start: начало)-->
deinit-->
the_end();

# Хорошо
script_8348-->
init-->
render-->
start-->
deinit-->
the_end();
```

#### 1.6. Чистим мусор

Перед передачей кода в следующий этап работы, нужно убрать из него все `console.log()`-и и `debugger`-ы, закомментированные куски кода и т.п.

#### 1.7. Назначение функции должно соответствовать её названию

Это называется очевидное поведение. Если вам нужно, что бы функция делала что-то дургое, то назовите функцию по другому. Не всегда это получается, но к этому нужно стремиться.

Пример:

```coffee
# Плохо
# Добавление CSS-классов стоит по умолчанию, что является неочевидным поведением
# Мутации внешних сущностей трудно отслеживать, что усложняет код
check_positions = (expected_array, add_wrong_class=true) =>
  is_right = true
  for slot, index in @slots
    if slot.data("plate") != null
      plate = slot.data "plate"
      answer = plate.data "index"

      if typeof(expected_array[index]) == 'object'
        # if plate position can vary
        if expected_array[index].indexOf(answer) == -1
          if add_wrong_class
            plate.addClass @WRONG_STATE
          plate.data "is_wrong", true
          if is_right
            is_right = false
      else
        # plate position is uniquely
        if answer != expected_array[index]
          if add_wrong_class
            plate.addClass @WRONG_STATE
          plate.data "is_wrong", true
          if is_right
            is_right = false
    else
      # Wrong if any of slots doesn't have plate
      is_right = false

  return is_right

# Хорошо
isRightPositions = (expectedArray) =>
  @slots
    .map((slot) -> slot.data('plate').data('index'))
    .every((answer, i) ->
      if typeof expectedArray[i] == 'object'
        expectedArray[i].indexOf(answer) != -1
      else
        answer == expectedArray[i]
    )
```

#### 1.8. ФП. Отказываемся от циклов

Давайте хотя бы избавимся от циклов. В CoffeeScript у блоков инструкций циклов нет своей области видимости, что приводит иногда к неочевидному поведению. Так же из стандартных методов `Array` можно составлять удобные цепочки.

Плюс ко всему CoffeeScript нам позваляет создавать массивы из диапозонов (например: `[0..5]`).

**UPD: Если где-то неудобно использовать функции высшего порядка, то можно использовать циклы. Но старайтесь избегать этого.**

Пример 1:

TODO: Вставить пример с замыканиями в СoffeeScript-е (с компонентом Axis).

Пример 2:

```coffee
# Не очень хорошо
$$.Script.prototype.chebox_init = (cb) ->
  checkboxes = []

  i_right = Math.round(@gen.checkboxes.length/2)
  top = -80

  for checkbox, idx in @gen.checkboxes
    left = if idx%2 == 0 then 0 else 210
    checkboxes.push new $$.Checkbox (
      right: checkbox,
      pos: {left: left, top: top + 80*Math.floor(idx/2 + 1)},
      width: 170
      label: "<span>#{@gen.label}</span> = #{@gen.dot[idx]}"
      MQ: @MQ
    )

  @checkboxes = new $$.Checkboxes checkboxes: checkboxes
    .appendTo @dom.main

  @dom.main.appendTo @dom.scene
  cb()

# Хорошо
$$.Script.prototype.init = (cb) ->
  @com = {
    checkboxes: @gen.checkboxes
      .map((value, i) =>
        new $$.Checkbox({
          right: value
          pos: {
            left: if i % 2 == 0 then 0 else 210
            top: -80 + 80 * Math.floor(i / 2 + 1)
          }
          width: 170
          label: "<span>#{@gen.label}</span> = #{@gen.dot[i]}"
          MQ: @MQ
        })
      )
  }

  @dom = {
    checkboxesContainer: $.div('checkbox-container')
    checkboxes: @com.checkboxes.map((object) -> object.dom.self)
  }

  cb()

$$.Script.prototype.render = (cb) ->
  @dom.scene.append(
    @dom.checkboxesContainer.append(
      @dom.checkboxes...
    )
  )

  cb()
```

Пример 3: [1.7. Назначение функции должно соответствовать её названию](#17-Назначение-функции-должно-соответствовать-её-названию)

#### 1.9. ООП. Общаемся с сущносями на их языке

Если у нас есть какие то сущности (инстансы компонентов) со своим API, то лучше использовать их методы, а не сторонние функции. Код будет компактнее и понятнее.

Кроме тех случаев, когда компонент написан не очень хорошо.

Пример:

```coffee
# Плохо
@dom.button.addClass('button_wrong')

# Не очень хорошо
$$.button__animate(@dom.button, "wrong", {}, () => {...})

# Хорошо
@com.button.animate('wrong', () => {...})
```

### 2. Работа с графом

#### 2.1. Переменные

##### Переменная `@salt`

В переменной `@salt` находятся наши генерации из `card.json`.

##### Переменная `@gen`

Генерации клонируем из переменной `@salt` в переменную `@gen`. Далее переменную `@salt` мы нигде не используем, что бы избежать случайных мутаций.

##### Переменная `@var`

Если нужны какие-то дополнительные переменные (константы) в области видимости скрипта, записываем их в переменную `@var`.

##### Переменная `@state`

Если у нашего скрипта четко прослеживается какие то состояния, то можно записать их в переменную `@state`.

Пример:

```coffee
@state = {
  # текущий индекс в цикле в графе (например, если у нас много экранов)
  index: 0
  # также мы можем передавать состояние ошибки
  error: false
  # и сохранять действия не в графе, а в состоянии
  action: null
}
```

##### Переменная `@com`

Все инстансы компонентов мы храним в переменной `@com`.

##### Переменная `@dom`

Все jQuery-элементы компонентов мы храним в переменной `@dom`.

##### Переменная `@obj`

В переменной `@obj` находится послежний активный jQuery-элемент.

#### 2.2. Шаг `init`. Инициализация

Отделяем инстансы компонентов от jQuery-элементов. Записываем все инстансы компонентов в переменную `@com`, а jQuery-элементы в `@dom`. Так нам всегда будет видно в коде, к какой именно сущности мы обращаемся.

Все инстансы и jQuery-элементы создаем в шаге `init`. Можно разделять инициализацию на несколько шагов, если это вам нужно, но все их названия должны начинаться с `init...` и находиться до шага `render`.

Иногда для некоторых компонетов и методов (`@tutor.speaker()`, `$$.Dragger()`) требуется наличие в DOM-е передаваемых им элементов в отрендеренном состоянии, для рассчета их позиций (что не очень хорошо), поэтому создание этих элементов может происходить в других шагах после шага `render` или в самом шаге `render`.

Пример 1:

```coffee
# Плохо
$$.Script.prototype.init = (cb) ->
  @gen = @salt

  cb()

# Не очень хорошо
$$.Script.prototype.init = (cb) ->
  @gen = $.extend(true, {}, @salt)

  @rightValue = Math.max(@gen.values)

  @button = new $$.Button({
    text: @tutor.t('done')
  })

  @title = $.div('title').html(@tutor.t('title'))
  @buttonElement = @button.view
  @buttonContainer = $.div('button-container')

  cb()

# Хорошо
$$.Script.prototype.init = (cb) ->
  # Generations
  @gen = $.extend(true, {}, @salt)

  # Variables
  @var = {
    rightValue: Math.max(@gen.values)
  }

  # State
  @state = {
    index: 0
    error: false
    action: null
  }

  # Components
  @com = {
    button: new $$.Button({
      text: @tutor.t('done')
    })
  }

  # DOM
  @dom = {
    title: $.div('title')
      .html(@tutor.t('title'))
    button: @com.button.view
    buttonContainer: $.div('button-container')
  }

  cb()
```

Пример 2: [1.8. ФП. Отказываемся от циклов](#18-ФП-Отказываемся-от-циклов)

#### 2.3. Шаг `render`. Рендеринг

Групповой рендер элементов в DOM. Так как DOM в браузере достаточно медленная структура, то лучше пореже обращаться к ней. Хоть для нас и не очень важна пока что производительность, но лучше привыкать к этому сразу.

Почти весь рендер (большая часть) должен происходить в шаге `render`. Можно разделять рендер на несколько шагов, если это вам нужно, но все их названия должны начинаться с `render...`. Например, если нужна инициализация каких то компонентов, требующих уже отрендеренных компонентов.

Плюс, если мы будем рендерить все первые элементы все разом в шаге `render`, то унас будет перед глазами наглядная структура того, что у нас есть в DOM-е на данный момент.

Пример 1:

```coffee
# Не очень хорошо
$$.Script.prototype.render = (cb) ->
  # Scene
  @scene = $$.scene__draw(@place, { grid: true })

  @title.appendTo(@scene)
  @buttonContainer.appendTo(@scene)
  @buttonElement.appendTo(@buttonContainer)

  cb()

# Хорошо
$$.Script.prototype.render = (cb) ->
  # Scene
  @dom.scene = $$.scene__draw(@place, { grid: true }).append(
    @dom.title
    @dom.buttonContainer.append(
      @dom.button
    )
  )

  cb()
```

Пример 2: [1.8. ФП. Отказываемся от циклов](#18-ФП-Отказываемся-от-циклов)

#### 2.4. Шаг `start`. Начало

Здесь мы только отображаем нашу кнопку `play_button` и слушаем нажатие.

Пример:

```coffee
# Хорошо
$$.Script.prototype.start = (cb) ->
  @tutor.play_button(cb)
```

#### 2.5. Шаг `continue`. Продолжение

Этот шаг вспомогательный. Сюда мы возвращаемся каждый раз, если у нас есть какие-то циклические повторения (экраны, fork-и, проверки). Здесь же мы сбрасываем состояние нашего скрипта, если нужно (`@state.action`, `@state.error`).

Пример:

```coffee
# Хорошо
$$.Script.prototype.continue = (cb) ->
  @state.action = null
  @state.error = false

  cb()
```

#### 2.6. Шаг `deinit`. Окончание

Здесь мы очищаем нашу сцену, и снимаем обработчики событий с других элементов, если нужно.

Пример:

```coffee
# Хорошо
$$.Script.prototype.deinit = (cb) ->
  $$.scene__clear(@dom.scene)

  cb()
```

## Ссылки

- [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript)

## Changelog

#### 09.08.2017

- 1.3. — добавлен параграф о пробелах, отступах и переносах
- 2.1. — добавлен параграф о переменных
- 2.2. — поправлены ошибки

#### 08.08.2017

- 1.4. — оставляем комментарии в графе, там где это необходимо.
- 1.7. — оставляем возможность использовать циклы, там где это необходимо.

#### 07.08.2017

- Первая версия
